# Git guide for Portals project

**Created**: 2025-11-11
**Audience**: Developers learning Git
**Project**: Portals (DocSync)

---

## What is Git?

**Git** is a version control system that tracks changes to your code over time. Think of it as a time machine for your project - you can go back to any previous state, see what changed, and collaborate with others without overwriting each other's work.

### Key concepts

**Repository (repo)**: Your project folder tracked by Git
**Commit**: A snapshot of your project at a specific point in time
**Branch**: A parallel version of your project (like a timeline branch)
**Remote**: A copy of your repository on another computer (like GitHub)

---

## Git for the Portals project

### What to commit to Git ‚úÖ

**Source code** - Always commit:
- All `.py` files (your Python code)
- `pyproject.toml` (project configuration)
- `README.md`, `AGENT_CONTEXT.md` (documentation)
- Test files (`tests/`)
- Configuration templates (`.env.example`)

**Documentation** - Always commit:
- All `.md` files in `01-context/`, `02-research/`, etc.
- Architecture diagrams
- API documentation
- Usage examples

**Configuration** - Commit templates:
- `.env.example` (template without secrets)
- `.gitignore` (tells Git what NOT to track)
- `pyproject.toml` (dependencies and project settings)

### What NOT to commit to Git ‚ùå

**Secrets and credentials** - NEVER commit:
- `.env` (contains API keys)
- API keys or tokens
- Passwords or credentials
- OAuth tokens
- Any file with real secrets

**Generated files** - Don't commit:
- `__pycache__/` (Python bytecode)
- `.pytest_cache/` (test cache)
- `*.pyc`, `*.pyo` (compiled Python)
- `.DS_Store` (macOS system files)
- `dist/`, `build/` (build artifacts)

**Local state** - Don't commit:
- `.docsync/` (local sync metadata)
- `.venv/`, `venv/` (virtual environment)
- IDE settings (`.vscode/`, `.idea/`) - unless team agrees
- Log files (`*.log`)
- Temporary files (`*.tmp`, `*.swp`)

### Special case: `.docsync/` metadata

**Decision for Portals**: ‚ùå **DO NOT commit** `.docsync/` to Git

**Why?**
- Contains local file paths (different on each machine)
- Contains sync state (personal to each developer)
- Changes frequently (on every sync)
- May contain sensitive info (Notion page IDs)

**What this means:**
- Each developer initializes their own `.docsync/`
- Each developer has their own sync state
- Works great for personal projects
- For team projects, we'll handle this differently in the future

---

## Setting up Git for Portals

### Step 1: Initialize Git repository

```bash
cd ~/Documents/Claude\ Code/docsync/
git init
```

This creates a `.git` folder (hidden) that tracks all changes.

### Step 2: Create `.gitignore`

This file tells Git what NOT to track:

```bash
# Create .gitignore file
touch .gitignore
```

Add this content (I'll create this file for you):

```gitignore
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual environments
.venv/
venv/
ENV/
env/

# Testing
.pytest_cache/
.coverage
htmlcov/
.tox/

# IDEs
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Environment variables and secrets
.env
*.pem
*.key

# Portals-specific
.docsync/
*.log

# Temporary files
*.tmp
*.bak
```

### Step 3: Make your first commit

```bash
# Add all files (respecting .gitignore)
git add .

# Create your first commit
git commit -m "Initial commit: Project structure and planning docs"
```

---

## Daily Git workflow

### Making changes

```bash
# 1. Check what files you've changed
git status

# 2. See exactly what changed
git diff

# 3. Add files you want to commit
git add docsync/core/models.py
git add tests/test_models.py

# Or add everything
git add .

# 4. Commit with a clear message
git commit -m "Add Document and SyncPair models"

# 5. Push to remote (if using GitHub)
git push
```

### Checking history

```bash
# See commit history
git log

# See last 5 commits (prettier)
git log --oneline -5

# See what changed in last commit
git show
```

### Undoing changes

```bash
# Discard changes to a file (dangerous!)
git checkout -- docsync/core/models.py

# Undo last commit (keep changes)
git reset --soft HEAD~1

# Undo last commit (discard changes - dangerous!)
git reset --hard HEAD~1
```

---

## Pro tips from senior engineers

### 1. Commit often, commit early

‚ùå **Bad**: Work for 3 days, make one huge commit
‚úÖ **Good**: Make small commits every time you complete a piece

**Why?**
- Easy to find bugs (small changes)
- Easy to undo mistakes
- Clear history of what you did

**Example workflow**:
```bash
# Implement a feature
git commit -m "Add LocalFileAdapter.read() method"

# Add tests
git commit -m "Add tests for LocalFileAdapter"

# Fix a bug found during testing
git commit -m "Fix encoding issue in LocalFileAdapter"
```

### 2. Write clear commit messages

‚ùå **Bad**:
- "fix bug"
- "updates"
- "wip"
- "asdfasdf"

‚úÖ **Good**:
- "Add 3-way merge algorithm to SyncEngine"
- "Fix conflict detection when both sides deleted"
- "Refactor NotionAdapter to use async/await"

**Format**: Start with a verb, describe what and why

### 3. Use branches for features

**Main branch** (`main` or `master`): Always working code
**Feature branches**: Where you develop new features

```bash
# Create a new branch for a feature
git checkout -b feature/notion-adapter

# Work on your feature, make commits
git commit -m "Add NotionAdapter skeleton"
git commit -m "Implement block conversion"

# When done, merge back to main
git checkout main
git merge feature/notion-adapter

# Delete the feature branch
git branch -d feature/notion-adapter
```

**Why branches?**
- Main branch stays stable
- Experiment freely
- Easy to abandon failed experiments

### 4. Review before committing

```bash
# Always check what you're about to commit
git status
git diff

# Add files selectively (not blindly)
git add specific-file.py

# Review what's staged
git diff --staged

# Then commit
git commit -m "Clear message"
```

**Watch out for**:
- Accidentally committing `.env` (secrets!)
- Committing `__pycache__/` (use .gitignore)
- Committing debug print statements
- Committing commented-out code

### 5. The `.env` secret protection

**NEVER commit `.env` to Git!**

**Safe pattern**:
1. Create `.env.example` (commit this):
   ```bash
   NOTION_API_KEY=your_key_here
   GOOGLE_WORKSPACE_EMAIL=your_email_here
   ```

2. Create `.env` (DON'T commit this):
   ```bash
   NOTION_API_KEY=secret_real_key_abc123...
   GOOGLE_WORKSPACE_EMAIL=real@email.com
   ```

3. Add `.env` to `.gitignore`

4. Document in README: "Copy `.env.example` to `.env` and fill in your keys"

### 6. Atomic commits

Each commit should be **one logical change**.

‚ùå **Bad** (multiple unrelated changes):
```bash
git commit -m "Add NotionAdapter, fix bug in LocalAdapter, update README, refactor tests"
```

‚úÖ **Good** (separate commits):
```bash
git commit -m "Add NotionAdapter with block conversion"
git commit -m "Fix encoding bug in LocalAdapter"
git commit -m "Update README with Notion setup instructions"
git commit -m "Refactor adapter tests to use fixtures"
```

**Why?**
- Easy to understand each change
- Easy to cherry-pick specific fixes
- Easy to revert without losing other work

### 7. Don't commit broken code to main

**Rule**: Main branch should always work

```bash
# Before committing to main, run tests
pytest

# If tests pass, commit
git commit -m "Add feature X"

# If tests fail, fix first
git commit -m "Fix tests for feature X"
```

**Exception**: Feature branches can have broken code (that's what they're for!)

### 8. Use `.gitignore` effectively

**Always add** `.gitignore` before first commit

**Pro tip**: Generate with `gitignore.io`
```bash
# For Python projects
curl -L https://www.gitignore.io/api/python,venv,visualstudiocode > .gitignore
```

Then customize for your project (add `.docsync/`, etc.)

---

## Common Git pitfalls (and how to avoid them)

### Pitfall 1: Committing secrets

‚ùå **Problem**:
```bash
git add .env
git commit -m "Add config"
git push
# Oh no! API key is now public forever!
```

‚úÖ **Solution**:
1. Use `.gitignore` to block `.env`
2. If you accidentally commit secrets:
   ```bash
   # Remove from Git history (complex, ask for help)
   # Immediately rotate the exposed keys!
   ```

### Pitfall 2: Lost work from `git reset --hard`

‚ùå **Problem**:
```bash
git reset --hard HEAD~1
# All your changes are gone! üò±
```

‚úÖ **Prevention**:
- Only use `--hard` if you're SURE
- Better: Use `--soft` to keep changes
- Or: Stash changes instead
  ```bash
  git stash  # Save changes for later
  git stash pop  # Restore them
  ```

### Pitfall 3: Merge conflicts

**What is it?**
Two people changed the same lines of code.

**Example**:
```python
<<<<<<< HEAD
def sync(self):
    return "version 1"
=======
def sync(self):
    return "version 2"
>>>>>>> feature-branch
```

**How to fix**:
1. Open the file in editor
2. Decide which version to keep (or merge both)
3. Remove the conflict markers (`<<<<<<<`, `=======`, `>>>>>>>`)
4. Save and commit:
   ```bash
   git add file.py
   git commit -m "Resolve merge conflict in sync()"
   ```

### Pitfall 4: Committing to wrong branch

‚ùå **Problem**:
```bash
# Oops, I'm on main branch
git commit -m "Experimental feature"
```

‚úÖ **Fix**:
```bash
# Move commit to correct branch
git reset --soft HEAD~1  # Undo commit, keep changes
git stash  # Save changes
git checkout feature-branch
git stash pop  # Restore changes
git commit -m "Experimental feature"
```

---

## Git workflow for Portals project

### Recommended branching strategy

```
main (always working)
‚îú‚îÄ‚îÄ feature/phase-0-foundation
‚îú‚îÄ‚îÄ feature/phase-1-local-adapter
‚îú‚îÄ‚îÄ feature/phase-2-notion-adapter
‚îî‚îÄ‚îÄ feature/phase-3-mirror-mode
```

**Workflow**:
```bash
# Starting Phase 0
git checkout -b feature/phase-0-foundation

# Work, commit frequently
git commit -m "Set up project structure"
git commit -m "Add base abstract classes"
git commit -m "Configure pytest"

# When phase is complete and tested
git checkout main
git merge feature/phase-0-foundation

# Tag the release
git tag -a v0.1.0 -m "Phase 0 complete: Foundation"

# Start next phase
git checkout -b feature/phase-1-local-adapter
```

### Commit message convention

**Format**: `<type>: <description>`

**Types**:
- `feat:` New feature
- `fix:` Bug fix
- `docs:` Documentation
- `test:` Add/update tests
- `refactor:` Code restructuring
- `chore:` Maintenance tasks

**Examples**:
```bash
git commit -m "feat: Add LocalFileAdapter with read/write methods"
git commit -m "test: Add tests for LocalFileAdapter"
git commit -m "fix: Handle encoding errors in LocalFileAdapter"
git commit -m "docs: Update README with setup instructions"
git commit -m "refactor: Extract hashing logic to utility module"
```

---

## Using GitHub (remote repository)

### Why use GitHub?

- **Backup**: Your code is safe in the cloud
- **Collaboration**: Others can contribute
- **Portfolio**: Show your work
- **CI/CD**: Automatic testing

### Setting up GitHub remote

```bash
# 1. Create repository on GitHub.com (don't initialize)

# 2. Add remote to your local repo
git remote add origin https://github.com/yourusername/portals.git

# 3. Push your code
git push -u origin main

# 4. Future pushes are simpler
git push
```

### Daily workflow with GitHub

```bash
# Before starting work, get latest changes
git pull

# Make changes, commit
git commit -m "Add feature"

# Push to GitHub
git push
```

### Cloning on another machine

```bash
# Download the repo
git clone https://github.com/yourusername/portals.git

# Enter directory
cd portals

# Set up Python environment
uv venv
source .venv/bin/activate
uv pip install -e .

# Copy and configure .env
cp .env.example .env
# Edit .env with your API keys

# Initialize local sync state
docsync init notion-mirror --teamspace=portals
```

---

## Git commands cheat sheet

### Setup and config

```bash
git init                    # Initialize new repo
git config --global user.name "Your Name"
git config --global user.email "you@example.com"
```

### Daily workflow

```bash
git status                  # See what changed
git diff                    # See detailed changes
git add file.py             # Stage file for commit
git add .                   # Stage all changes
git commit -m "Message"     # Create commit
git push                    # Send to remote
git pull                    # Get from remote
```

### Branching

```bash
git branch                  # List branches
git branch feature-name     # Create branch
git checkout feature-name   # Switch branch
git checkout -b feature-name  # Create and switch
git merge feature-name      # Merge branch into current
git branch -d feature-name  # Delete branch
```

### Viewing history

```bash
git log                     # Show commit history
git log --oneline -10       # Last 10 commits (compact)
git show                    # Show last commit
git show abc123             # Show specific commit
git diff HEAD~1             # Compare with previous commit
```

### Undoing things

```bash
git checkout -- file.py     # Discard changes to file
git reset HEAD file.py      # Unstage file
git reset --soft HEAD~1     # Undo commit, keep changes
git reset --hard HEAD~1     # Undo commit, discard changes (dangerous!)
git stash                   # Save changes for later
git stash pop               # Restore stashed changes
```

### Remote operations

```bash
git remote -v               # Show remotes
git remote add origin URL   # Add remote
git push -u origin main     # Push and set upstream
git push                    # Push to upstream
git pull                    # Fetch and merge
git fetch                   # Get changes (don't merge)
```

---

## Best practices summary

1. ‚úÖ **Commit often**: Small, focused commits
2. ‚úÖ **Clear messages**: Describe what and why
3. ‚úÖ **Review before commit**: Check `git status` and `git diff`
4. ‚úÖ **Use .gitignore**: Protect secrets, ignore generated files
5. ‚úÖ **Never commit secrets**: Use `.env.example` pattern
6. ‚úÖ **Keep main stable**: Use branches for experiments
7. ‚úÖ **Test before merging**: Run `pytest` before merging to main
8. ‚úÖ **Pull before push**: Get latest changes first
9. ‚úÖ **Tag releases**: Mark milestones with tags
10. ‚úÖ **Document in README**: Help others (and future you)

---

## For Portals project specifically

### What to commit ‚úÖ

```
.gitignore
README.md
AGENT_CONTEXT.md
01-context/
02-research/
pyproject.toml
.env.example
docsync/              # All source code
tests/                # All tests
docs/                 # Documentation
examples/             # Examples
```

### What NOT to commit ‚ùå

```
.env                  # Contains real API keys
.docsync/             # Local sync state
__pycache__/          # Python cache
.venv/                # Virtual environment
*.log                 # Log files
.DS_Store             # macOS files
```

### Commit workflow per phase

```bash
# Starting Phase 0
git checkout -b feature/phase-0-foundation

# Each task completion
git add docsync/core/models.py
git commit -m "feat: Add Document and SyncPair models"

git add tests/test_models.py
git commit -m "test: Add tests for Document model"

# Phase complete
pytest  # Make sure tests pass
git checkout main
git merge feature/phase-0-foundation
git tag -a v0.1.0 -m "Phase 0 complete"
git push --tags
```

---

## Resources for learning more

**Interactive tutorials**:
- https://learngitbranching.js.org/ (visual, interactive)
- https://try.github.io/ (GitHub's tutorial)

**References**:
- https://git-scm.com/book/en/v2 (official Git book)
- https://ohshitgit.com/ (fixing common mistakes)

**Cheat sheets**:
- https://education.github.com/git-cheat-sheet-education.pdf

---

## Questions? Common scenarios

### "Should I commit this file?"

**Ask yourself**:
1. Is it source code I wrote? ‚Üí ‚úÖ Commit
2. Is it documentation? ‚Üí ‚úÖ Commit
3. Is it generated by a tool? ‚Üí ‚ùå Don't commit
4. Does it contain secrets? ‚Üí ‚ùå Don't commit
5. Is it specific to my machine? ‚Üí ‚ùå Don't commit

### "When should I make a commit?"

**Commit when**:
- You complete a logical piece of work
- Tests pass
- Code compiles/runs
- You're about to try something risky

**Don't wait until**:
- End of the day
- Feature is 100% perfect
- All tests pass (you can commit work-in-progress on feature branches)

### "How do I know if I'm doing it right?"

**Good signs**:
- Commit history reads like a story
- Each commit does one thing
- Can revert commits without breaking everything
- Your code is safe (backed up on GitHub)

---

## Next steps

1. **Initialize Git** for Portals project
2. **Create `.gitignore`** (I'll create this for you)
3. **Make first commit** with planning docs
4. **Create GitHub repo** (optional but recommended)
5. **Start Phase 0** with feature branch

Let's do this! üöÄ
